<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xl="http://www.w3.org/1999/xlink"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd
                             http://www.w3.org/1999/xlink http://docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:id="java_oort">
<info>
    <title>Scalability Clustering with Oort</title>
</info>
<para>
    The CometD distribution ships a clustering solution called <emphasis>Oort</emphasis> that
    enhances the scalability of a CometD-based system.
    Instead of connecting to a single node (usually represented by a virtual or physical host), clients connect
    to multiple nodes so that the processing power required to cope with the load is spread among multiple nodes,
    giving the whole system more scalability than using a single node.
</para>
<para>
    Oort clustering <emphasis role="bold">is not</emphasis> a high availability clustering solution: if one of
    the nodes crashes, then all the clients are disconnected and reconnect to other nodes (with a new
    handshake).
    All the information built by one client with its server up to that point (for example, the state of an
    online chess game) is generally lost (unless the application has implemented some other way
    to retrieve that information).
</para>
<section>
<info>
    <title>Typical Infrastructure</title>
</info>
<para>
    A typical, but not the only, infrastructure to set up an Oort cluster is to have a load balancer in front
    of Oort nodes, so that clients can connect transparently to any node.
    The load balancer should implement stickyness, which can be based on:
<itemizedlist>
<listitem>
<para>The remote IP address.</para>
</listitem>
<listitem>
<para>CometD's BAYEUX_BROWSER cookie (see the <xref linkend="bayeux_multiple_clients" />).</para>
</listitem>
<listitem>
<para>Some other mechanism the load balancer supports.</para>
</listitem>
</itemizedlist>
</para>
<para>
    You should configure DNS with a single host name/IP address pair (that of the load balancer), so
    that in case of a node crash, when clients attempt to reconnect to the same host name, the load
    balancer notices that the node has crashed and directs the connection to another node.
    The second node does not know about this client, and upon receiving the connect request sends to
    the client the advice to handshake.
</para>
<mediaobject>
    <alt>Typical Oort Infrastructure</alt>
    <imageobject>
        <imagedata align="center" fileref="oort_infrastructure.png" format="PNG" width="3in" />
    </imageobject>
</mediaobject>
</section>
<section>
<info>
    <title>Terminology</title>
</info>
<para>
    The next sections use the following terminology:
    <itemizedlist>
    <listitem>
    <para>An <emphasis>Oort cluster</emphasis> is also referred to
    as an <emphasis>Oort cloud</emphasis>; it follows that <emphasis>cloud</emphasis> is a synonym for <emphasis>cluster</emphasis>.)</para>
    </listitem>
    <listitem>
    <para>An Oort node is also referred to
    an <emphasis>Oort comet</emphasis>; it follows that <emphasis>comet</emphasis> is a synonym for <emphasis>node</emphasis>).</para>
    </listitem>
    </itemizedlist>
</para>
</section>
<section>
<info>
<title>Oort Cloud</title>
</info>
<para>
Any CometD server can become an Oort comet by configuring an instance of
<classname>org.cometd.oort.Oort</classname>.
The <classname>org.cometd.oort.Oort</classname> instance is associated to the
<classname>org.cometd.bayeux.server.BayeuxServer</classname> instance, and there can be only one
<code>Oort</code> instance for each <code>BayeuxServer</code> instance.
</para>
<para>
Oort comets need to know each others' URLs to connect and form a cloud.
A new comet that wants to join the cloud needs to know at least one URL of another comet that is already
part of the cloud.
Once it has connected to one comet, the cloud informs the new comet of the other comets to which the
new comet is not yet connected, and the new comet then connects to all the existing nodes.
</para>
<para>
There are two ways for a new comet to discover at least one other comet:
<itemizedlist>
<listitem>
    <para>At runtime, via automatic discovery based on multicast.</para>
</listitem>
<listitem>
    <para>At startup time, via static configuration.</para>
</listitem>
</itemizedlist>
</para>

<section xml:id="java_oort_common_configuration">
<info>
    <title>Common Configuration</title>
</info>
<para>
    For both static and automatic discovery there exists a set of parameters that you can use to configure
    the <code>Oort</code> instance.
    The following is the list of common configuration parameters the automatic discovery
    and static configuration servlets share:
</para>
<table>
<caption>Oort Common Configuration Parameters</caption>
<tgroup cols="4">
<thead>
<row>
    <entry>Parameter Name</entry>
    <entry>Required</entry>
    <entry>Default Value</entry>
    <entry>Parameter Description</entry>
</row>
</thead>
<tbody>
<row>
    <entry>oort.url</entry>
    <entry>Y</entry>
    <entry>N/A</entry>
    <entry>The unique URL of the Bayeux server associated to the Oort comet</entry>
</row>
<row>
    <entry>oort.secret</entry>
    <entry>N</entry>
    <entry>random string</entry>
    <entry>The pre-shared secret that authenticates connections from other Oort comets</entry>
</row>
<row>
    <entry>oort.channels</entry>
    <entry>N</entry>
    <entry>empty string</entry>
    <entry>A comma-separated list of channels to observe at startup</entry>
</row>
<row>
    <entry>enableAckExtension</entry>
    <entry>N</entry>
    <entry>false</entry>
    <entry>
        Whether to enable the message acknowledgement extension (<xref linkend="extensions_acknowledge" />)
        in the <code>BayeuxServer</code> instance and in the <code>OortComet</code> instances
    </entry>
</row>
<row>
    <entry>clientDebug</entry>
    <entry>N</entry>
    <entry>false</entry>
    <entry>Whether to enable debug logging in the <code>OortComet</code> instances</entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section>
<info>
    <title>Automatic Discovery Configuration</title>
</info>
<para>
    You can configure the automatic discovery mechanism either via code, or by configuring a
    <classname>org.cometd.oort.OortMulticastConfigServlet</classname> in <filename>web.xml</filename>,
    for example:
</para>
<informalexample>
<programlisting language="xml"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
     version="2.5">

    <servlet>
        <servlet-name>cometd</servlet-name>
        <servlet-class>org.cometd.server.CometdServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>cometd</servlet-name>
        <url-pattern>/cometd/*</url-pattern>
    </servlet-mapping>

    <servlet>
        <servlet-name>oort</servlet-name>
        <servlet-class>org.cometd.oort.OortMulticastConfigServlet</servlet-class>
        <load-on-startup>2</load-on-startup>
        <init-param>
            <param-name>oort.url</param-name>
            <param-value>http://host:port/context/cometd</param-value>
        </init-param>
    </servlet>
</web-app>
]]></programlisting>
</informalexample>
<para>
    Since <code>Oort</code> depends on <code>BayeuxServer</code>, the <code>load-on-startup</code>
    parameter of the <code>OortMulticastConfigServlet</code> must be greater than that of the
    <code>CometdServlet</code>.
</para>
<para>
    The mandatory <code>oort.url</code> init parameter must identify the URL at which this Oort comet
    can be contacted, and it must be the URL the <code>CometdServlet</code> of this node serves.
    This URL is sent to other Oort comets, so it is important that the host part of the URL does
    not point to "localhost", but to a resolvable host name or to an IP address, so that other comets
    in the cluster can contact this comet.
    Likewise, you must properly configure the context path part of the URL for this web application.
</para>
<para>
    In addition to the common configuration init parameters, <code>OortMulticastConfigServlet</code>
    supports the configuration of these additional init parameters:
</para>

<table>
<caption>Oort Multicast Configuration Parameters</caption>
<tgroup cols="4">
<thead>
<row>
    <entry>Parameter Name</entry>
    <entry>Required</entry>
    <entry>Default Value</entry>
    <entry>Parameter Description</entry>
</row>
</thead>
<tbody>
<row>
    <entry>oort.multicast.bindAddress</entry>
    <entry>N</entry>
    <entry>the wildcard address</entry>
    <entry>The bind address of the MulticastSocket that receives the advertisements</entry>
</row>
<row>
    <entry>oort.multicast.groupAddress</entry>
    <entry>N</entry>
    <entry>239.255.0.1</entry>
    <entry>The multicast group address to join to receive the advertisements</entry>
</row>
<row>
    <entry>oort.multicast.groupPort</entry>
    <entry>N</entry>
    <entry>5577</entry>
    <entry>The port over which advertisements are sent and received</entry>
</row>
<row>
    <entry>oort.multicast.timeToLive</entry>
    <entry>N</entry>
    <entry>1</entry>
    <entry>The time to live of advertisement packets (1 = same subnet, 32 = same site, 255 =
        global)
    </entry>
</row>
<row>
    <entry>oort.multicast.advertiseInterval</entry>
    <entry>N</entry>
    <entry>1000</entry>
    <entry>The interval in milliseconds at which advertisements are sent</entry>
</row>
</tbody>
</tgroup>
</table>

<para>
    Each comet that you configure with automatic discovery emits an advertisement (containing the
    comet URL) every <code>oort.multicast.advertiseInterval</code> milliseconds on the specified
    multicast address and port (<code>oort.multicast.groupAddress</code> and
    <code>oort.multicast.groupPort</code>) with the specified time-to-live
    (<code>oort.multicast.timeToLive</code>).
    Advertisements continue until the web application is stopped, and only serve to advertise that a
    new node has appeared.
    <code>Oort</code> has a built-in mechanism that takes care of membership organization
    (see <xref linkend="java_oort_membership_organization" /> for details).
</para>

<para>
    When enabling the Oort automatic discovery mechanism, you must be sure that:
</para>

<itemizedlist>
<listitem>
    <para>Multicast is enabled in the operating system of your choice.</para>
</listitem>
<listitem>
    <para>The network interfaces have multicast enabled.</para>
</listitem>
<listitem>
    <para>Multicast traffic routing is properly configured.</para>
</listitem>
</itemizedlist>

<para>
    Linux is normally compiled with multicast support in the most common distributions. You can control network
    interfaces with the <code>ifconfig</code> command to check if they have
    multicast enabled.
    You can check multicast routing with the command <code>route -n</code>, and the output should
    contain a line similar to:
</para>
<screen>
Destination    Gateway    Genmask      Flags    Metric    Ref    Use    Iface
224.0.0.0      0.0.0.0    240.0.0.0      U         0       0      0     eth0
</screen>
<para>
    You might also want to force the JVM to prefer an IPv4 stack by setting the system property
    <code>-Djava.net.preferIPv4Stack=true</code> to facilitate multicast networking.
</para>
</section>
<section>
<info>
    <title>Static Discovery Configuration</title>
</info>
<para>
    You can use the static discovery mechanism if multicast is not available on the system where
    CometD is deployed.
    It is only slightly more cumbersome to set up. It does not allow dynamic discovery of new nodes,
    but it is enough to configure each comet with the well-known URL of an existing, started, comet
    (often named "master").
    The master comet should, of course, be started before all other comets.
</para>
<para>
    You can accomplish the static discovery configuration either via code, or by configuring an
    <classname>org.cometd.oort.OortStaticConfigServlet</classname> in <filename>web.xml</filename>,
    for example:
</para>
<informalexample>
<programlisting language="xml"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
     version="2.5">

    <servlet>
        <servlet-name>cometd</servlet-name>
        <servlet-class>org.cometd.server.CometdServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>cometd</servlet-name>
        <url-pattern>/cometd/*</url-pattern>
    </servlet-mapping>

    <servlet>
        <servlet-name>oort</servlet-name>
        <servlet-class>org.cometd.oort.OortStaticConfigServlet</servlet-class>
        <load-on-startup>2</load-on-startup>
        <init-param>
            <param-name>oort.url</param-name>
            <param-value>http://host:port/context/cometd</param-value>
        </init-param>
    </servlet>
</web-app>
]]></programlisting>
</informalexample>
<para>
    Just as for the automatic discovery, the <code>load-on-startup</code> parameter of the
    <code>OortStaticConfigServlet</code> must be greater than that of the <code>CometdServlet</code>.
</para>
<para>
    <code>OortStaticConfigServlet</code> supports the common init parameters listed in the previous
    section, and the following additional init parameter:
</para>
<table>
<caption>Oort Static Configuration Parameters</caption>
<tgroup cols="4">
<thead>
<row>
    <entry>Parameter Name</entry>
    <entry>Required</entry>
    <entry>Default Value</entry>
    <entry>Parameter Description</entry>
</row>
</thead>
<tbody>
<row>
    <entry>oort.cloud</entry>
    <entry>N</entry>
    <entry>empty string</entry>
    <entry>A comma-separated list of URLs of other Oort comets to connect to at startup</entry>
</row>
</tbody>
</tgroup>
</table>
<para>
    Configured in this way, the Oort comet is ready to be part of the Oort cloud, but it's not part
    of the cloud yet, since it does not know the URLs of other comets (and there is no automatic
    discovery).
    To make the Oort comet part of the Oort cloud, you can configure the
    <code>oort.cloud</code> init parameter of the <code>OortStaticConfigServlet</code> with one (or
    a comma-separated list) of Oort comet URL(s) to connect to:
</para>
<informalexample>
<programlisting language="xml"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
     version="2.5">

    <servlet>
        <servlet-name>cometd</servlet-name>
        <servlet-class>org.cometd.server.CometdServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>cometd</servlet-name>
        <url-pattern>/cometd/*</url-pattern>
    </servlet-mapping>

    <servlet>
        <servlet-name>oort</servlet-name>
        <servlet-class>org.cometd.oort.OortStaticConfigServlet</servlet-class>
        <load-on-startup>2</load-on-startup>
        <init-param>
            <param-name>oort.url</param-name>
            <param-value>http://host1:port/context/cometd</param-value>
        </init-param>
        <init-param>
            <param-name>oort.cloud</param-name>
            <param-value>http://host2:port/context/cometd,http://host3:port/context/cometd</param-value>
        </init-param>
    </servlet>
</web-app>
]]></programlisting>
</informalexample>
<para>
    Alternatively, it's possible to write custom initialization code (see the section on
    <xref linkend="java_server_services_integration" />
    for suggestions on how to do so) that links the node to the Oort cloud (this might be useful if Oort
    comet URLs cannot be known a priori, but can be known at runtime), for example:
</para>
<informalexample>
<programlisting language="java"><![CDATA[
public class OortConfigurationServlet extends GenericServlet
{
    public void init() throws ServletException
    {
        // Grab the Oort object
        Oort oort = (Oort)getServletContext().getAttribute(Oort.OORT_ATTRIBUTE);

        // Figure out the URLs to connect to, using other discovery means
        List<String> urls = ...;

        // Connect to the other Oort comets
        for (String url : urls)
        {
            OortComet oortComet = oort.observeComet(url);
            if (!oortComet.waitFor(1000, BayeuxClient.State.CONNECTED))
                throw new ServletException("Cannot connect to Oort comet " + url);
        }
    }

    public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException
    {
        throw new ServletException();
    }
}
]]></programlisting>
</informalexample>
<para>"
    The <code>OortComet</code> instance that <code>Oort.observeComet(url)</code> returns is a
    specialized version of <code>BayeuxClient</code>, see <xref linkend="java_client" />.
</para>
</section>
<section xml:id="java_oort_membership_organization">
<info>
    <title>Membership Organization</title>
</info>
<para>
    When an Oort comet connects to another Oort comet, a bidirectional communication
    is established.
    If <code>cometA</code> connects to <code>cometB</code> (for example, via
    <code>oortA.observeComet(urlB)</code>), then an <code>OortComet</code> instance is created in
    <code>cometA</code> connected to <code>cometB</code>, and another <code>OortComet</code> instance
    is created in <code>cometB</code> connected to <code>cometA</code>.
</para>
<para>
    After this direct, bidirectional communication has been established, a special message broadcasts
    across the whole Oort cloud (on channel <code>/oort/cloud</code>) where the two comets broadcast their
    known siblings.
    Every node receiving this message that does not know about those siblings then establishes a
    bidirectional communication with them.
</para>
<para>
    For example, imagine that there are two simple Oort clouds, one made of comets A and B and the other
    made of comets C and D.
    When A and C connect, they broadcast their siblings (A broadcasts its siblings, now B and C,
    while C broadcasts its siblings, now A and D). All nodes connected, directly or indirectly, to the
    broadcaster receive this message.
    When C receives broadcasts from A's siblings it notices that one is itself (so it does nothing since it's already
    connected to A). The other is the unknown sibling B, and C establishes a bidirectional connection
    with B as well. Likewise, A receives the sibling broadcast message from C, and connects to D.
    Each new bidirectional connection triggers a sibling broadcast message on the
    whole cloud, until all comets are connected.
</para>
<para>
    If a comet crashes, for example D, then all other comets detect that and disconnect from the
    faulty comet.
</para>
<mediaobject>
    <alt>Oort Cloud Membership Organization</alt>
    <imageobject>
        <imagedata align="center" fileref="oort_cloud.png" format="PNG" scalefit="1" width="100%"/>
    </imageobject>
</mediaobject>
<para>
In this way, an Oort cloud is aware of its members, but it does not do anything useful for the application.
</para>
<para>
The next section covers broadcast message forwarding over the entire cloud.
</para>
</section>

<section>
<info>
<title>
    Listening for Membership Events
</title>
</info>
<para>
    Applications sometimes need to know when other comets join or leave the Oort cloud; they can do so by
    registering comet listeners that are notified when a new comet joins the cloud and when a comet
    leaves the cloud:
</para>
<informalexample>
<programlisting language="java"><![CDATA[
Oort oort = ...;
oort.addCometListener(new Oort.CometListener()
{
    public void cometJoined(Event event)
    {
        System.out.printf("Comet joined the cloud %s%n", event.getCometURL());
    }

    public void cometLeft(Event event)
    {
        System.out.printf("Comet left the cloud %s%n", event.getCometURL());
    }
});
]]></programlisting>
</informalexample>
<para>
    The <emphasis>comet joined</emphasis> event is notified only after the local Oort comet has allowed connection
    from the remote comet (this may be denied by a <code>SecurityPolicy</code>).
</para>
<para>
    When a comet joined event is notified, it is possible to obtain the <code>OortComet</code> connected
    to the remote Oort via <code>Oort.observeComet(String)</code>, and publish messages
    (or subscribe to additional channels):
</para>
<informalexample>
<programlisting language="java"><![CDATA[
final Oort oort = ...;
oort.addCometListener(new Oort.CometListener()
{
    public void cometJoined(Event event)
    {
        String cometURL = event.getCometURL();
        OortComet oortComet = oort.observeComet(cometURL);

        // Push information to the new comet
        oortComet.getChannel("/service/foo").publish("bar");
    }

    public void cometLeft(Event event)
    {
    }
});
]]></programlisting>
</informalexample>
<para>
    Applications can use comet listeners to synchronize comets; a new comet can request (or be pushed)
    application data that needs to be present in all comets (for example to warm up a cache).
    Such activities occur in concert with a <code>SecurityPolicy</code> that denies handshakes from
    remote clients until the new comet is properly warmed up (clients retry the handshakes until the
    new comet is ready).
</para>
</section>

<section>
<info>
    <title>Authentication</title>
</info>
<para>
    When an Oort comet connects to another Oort comet, it sends a handshake message containing an
    extension field that is peculiar to Oort with the following format:
</para>
<informalexample>
<programlisting language="json"><![CDATA[
{
    "channel": "/meta/handshake",
    ... /* other usual handshake fields */
    "ext": {
        "org.cometd.oort": {
            "oortURL": "http://halley.cometd.org:8080/cometd",
            "cometURL": "http://halebopp.cometd.org:8080/cometd",
            "oortSecret": "cstw27r+l+XqE62IrNZdCDiUObA="
        }
    }
}
]]></programlisting>
</informalexample>
<para>
    The <code>oortURL</code> field is the URL of the comet that initiates the handshake; the
    <code>cometURL</code> field is the URL of the comet that receives the handshake; the
    <code>oortSecret</code> is the base64 encoding of the SHA-1 digested bytes of the pre-shared
    secret of the initiating Oort comet (see the earlier section, <xref linkend="java_oort_common_configuration" />).
</para>
<para>
    These extension fields provide a way for an Oort comet to distinguish a handshake of a remote
    client (which might be subject to authentication checks) from a handshake performed by a remote comet.
    For example, assume that remote clients always send an extension field containing an
    authentication token; then it is possible to write an implementation of <code>SecurityPolicy</code>
    as follows (see also the section about <!-- TODO: relink to docbook section -->
    <link xl:href="http://cometd.org/documentation/2.x/howtos/authentication">authentication</link>):
</para>
<informalexample>
<programlisting language="java"><![CDATA[
public class OortSecurityPolicy extends DefaultSecurityPolicy
{
    private final Oort oort;

    private OortSecurityPolicy(Oort oort)
    {
        this.oort = oort;
    }

    @Override
    public boolean canHandshake(BayeuxServer server, ServerSession session, ServerMessage message)
    {
        // Local sessions can always handshake
        if (session.isLocalSession())
            return true;

        // Remote Oort comets are allowed to handshake
        if (oort.isOortHandshake(message))
            return true;

        // Remote clients must have a valid token
        Map<String, Object> ext = message.getExt();
        return ext != null && isValid(ext.get("token"));
    }
}
]]></programlisting>
</informalexample>
<para>
    The <code>Oort.isOortHandshake(Message)</code> method validates the handshake message and
    returns true if it is a handshake from another Oort comet that has been configured with the
    same pre-shared secret. The pre-shared secret must be explicitly set because it defaults to a
    random string that is different for each Oort comet.
</para>
</section>
<section>
<info>
    <title>Broadcast Messages Forwarding</title>
</info>
<para>
    Broadcast messages (that is, messages sent to non-meta and non-service channels, (see
    <xref linkend="javascript_subscribe" /> for further details)
    are by definition messages that all clients subscribing to the channel
    the message is being sent to should receive.
</para>
<para>
    In an Oort cloud, you might have clients connected to different comets that subscribe to the same channel.
    If <code>clientA</code> connects to <code>cometA</code>, <code>clientB</code> connects
    to <code>cometB</code> and <code>clientC</code> connects to <code>cometC</code>, when
    <code>clientA</code> broadcasts a message you want <code>clientB</code> and <code>clientC</code>
    to receive, the Oort cloud must forward the message (sent by
    <code>clientA</code> and received by <code>cometA</code>) to <code>cometB</code> and <code>cometC</code>.
</para>
<para>
    You accomplish this by configuring the Oort configuration servlets to set the
    <code>oort.channels</code> init parameter to a comma-separated list of channels whose messages
    are forwarded to the Oort cloud:
</para>
<informalexample>
<programlisting language="xml"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
     version="2.5">

    <servlet>
        <servlet-name>cometd</servlet-name>
        <servlet-class>org.cometd.server.CometdServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>cometd</servlet-name>
        <url-pattern>/cometd/*</url-pattern>
    </servlet-mapping>

    <servlet>
        <servlet-name>oort</servlet-name>
        <servlet-class>org.cometd.oort.OortMulticastConfigServlet</servlet-class>
        <load-on-startup>2</load-on-startup>
        <init-param>
            <param-name>oort.url</param-name>
            <param-value>http://host1:port/context/cometd</param-value>
        </init-param>
        <init-param>
            <param-name>oort.channels</param-name>
            <param-value>/stock/**,/forex/*,/alerts</param-value>
        </init-param>
    </servlet>
</web-app>
]]></programlisting>
</informalexample>
<para>
    Alternatively, you can use <code>Oort.observeChannel(String channelName)</code> to
    instruct a comet to listen for messages on that channel published to one of the known comets
    it is connected to.
</para>
<para>
    When <code>cometA</code> observes a channel, it means that messages sent on that channel, but
    received by other comets, are automatically forwarded to <code>cometA</code>.
</para>
<important>
    <para>
        Message forwarding is not bidirectional; if <code>cometA</code> forwards messages to
        other comets it is not automatic that the other comets forward messages to
        <code>cometA</code>.
        However, in most cases you configure the Oort comets in the same way by the same
        initialization code, and therefore all comets forward the same channels.
    </para>
</important>
<para>
    Forwarding of messages may be subject to temporary interruptions in case there is a temporary network
    connectivity failure between two comets.
    To overcome this problem, it is possible to configure the comets to enable the message acknowledgement
    extension (see <xref linkend="extensions_acknowledge" />) so that, for short failures, the messages
    lost can be resent.
    Refer to <xref linkend="java_oort_common_configuration" /> for the configuration details.
</para>
<para>
    Remember that the message acknowledgement extension is not a fully persistent solution for lost messages
    (for example it does not guarantee message redelivery in case of long failures).
    CometD does not provide yet a fully persistent solution for messages in case of long failures.
</para>
<para>
    Since it has the ability to observe messages published to broadcast channels, an Oort cloud can already
    implement a simple chat application among users connected to different nodes.
    In the example below, when <code>clientA</code> publishes a message on channel <code>/chat</code>
    (green arrow), it arrives on <code>cometA</code>; since <code>cometB</code> and <code>cometC</code>
    have been configured to observe channel <code>/chat</code>, they both receive the message
    from <code>cometA</code> (green arrows), and therefore they can deliver the chat message to
    <code>clientB</code> and <code>clientC</code> respectively (green arrows).
</para>
<mediaobject>
    <alt>Oort Chat</alt>
    <imageobject>
        <imagedata align="center" fileref="oort_chat.png" format="PNG" width="3in"/>
    </imageobject>
</mediaobject>
<para>
    If your application only needs to broadcast messages to clients connected to other comets, an
    <code>Oort</code> instance is all you need.
</para>
<para>
    If you need to send messages directly to particular clients (for example, <code>clientA</code>
    wants to send a message to <code>clientC</code> but not to <code>clientB</code>, then you need
    to set up an additional component of the Oort clustering called <emphasis>Seti</emphasis>, see
    <xref linkend="java_oort_seti" />.
</para>
</section>
</section>

<section xml:id="java_oort_seti">
<info>
    <title>Seti</title>
</info>
<para>
    <code>Seti</code> is the Oort clustering component that tracks clients connected to any comet in the
    cloud, and allows an application to send messages to particular client(s) in the cloud transparently,
    as if they were in the local comet.
</para>
<section>
<info>
    <title>Configuring Seti</title>
</info>
<para>
    Keep the following points in mind when configuring Seti:
</para>
<itemizedlist>
<listitem>
    <para>
    You must configure an <classname>org.cometd.oort.Seti</classname> instance with an associated
    <classname>org.cometd.oort.Oort</classname> instance, either via code or by configuring an
    <classname>org.cometd.oort.SetiServlet</classname> in <filename>web.xml</filename>.
    </para>
</listitem>
<listitem>
    <para>
    There may be only one instance of <code>Seti</code> for each <code>Oort</code>.
    </para>
</listitem>
<listitem>
    <para>
    The <code>load-on-startup</code> parameter of the <code>SetiServlet</code> must be greater
    than that of the <code>OortServlet</code>.
    </para>
</listitem>
<listitem>
    <para>
    <code>SetiServlet</code> does not have any configuration init parameter.
    </para>
</listitem>
</itemizedlist>
<para>
    A configuration example follows:
</para>
<informalexample>
<programlisting language="xml"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
     version="2.5">

    <servlet>
        <servlet-name>cometd</servlet-name>
        <servlet-class>org.cometd.server.CometdServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>cometd</servlet-name>
        <url-pattern>/cometd/*</url-pattern>
    </servlet-mapping>

    <servlet>
        <servlet-name>oort</servlet-name>
        <servlet-class>org.cometd.oort.OortServlet</servlet-class>
        <load-on-startup>2</load-on-startup>
        <init-param>
            <param-name>oort.url</param-name>
            <param-value>http://host:port/context/cometd</param-value>
        </init-param>
    </servlet>

    <servlet>
        <servlet-name>seti</servlet-name>
        <servlet-class>org.cometd.oort.SetiServlet</servlet-class>
        <load-on-startup>3</load-on-startup>
    </servlet>
</web-app>
]]></programlisting>
</informalexample>
</section>
<section>
<info>
    <title>Associating and Disassociating Users</title>
</info>
<para>
    <code>Seti</code> allows you to associate a unique string representation of a user with one or more
    <code>ServerSessions</code> (see <xref linkend="concepts" /> for more details on <code>ServerSession</code>).
</para>
<para>
    This normally occurs when the user first logs in to the application, and the unique string
    representation of the user can be anything that the user provides to authenticate itself (a user
    name, a token, a database ID). For brevity, this unique string representation of
    the user is called <code>userId</code>.
    The same <code>userId</code> may log in multiple times (for example from a desktop computer
    and from a mobile device), so it is associated to multiple <code>ServerSessions</code>.
</para>
<para>
    In practice, the best way to associate a <code>userId</code> with a <code>ServerSession</code>
    is in a <code>SecurityPolicy</code> during <!-- TODO: link to docbook section -->
    <link xl:href="http://cometd.org/documentation/2.x/howtos/authentication">authentication</link>, for example:
</para>
<informalexample>
<programlisting language="java"><![CDATA[
public class MySecurityPolicy extends DefaultSecurityPolicy
{
    private final Seti seti;

    public MySecurityPolicy(Seti seti)
    {
        this.seti = seti;
    }

    @Override
    public boolean canHandshake(BayeuxServer server, ServerSession session, ServerMessage message)
    {
        if (session.isLocalSession())
            return true;

        // Authenticate
        String userId = performAuthentication(session, message);
        if (userId == null)
            return false;

        // Associate
        seti.associate(userId, session);

        return true;
    }
}
]]></programlisting>
</informalexample>
<para>
    Alternatively, you can perform the association in a <code>BayeuxServer.Extension</code> or in a
    CometD service (see <xref linkend="java_server_services" />), in response to a specific message
    that the client always sends after a successful handshake.
</para>
<para>
    When a <code>Seti</code> instance first associates a <code>userId</code> with a session, it broadcasts a
    <emphasis>presence</emphasis> message on the cloud (on channel <code>/seti/all</code>, (see
    <xref linkend="java_oort_seti_listeners" />) that tells all
    the other comets where this <code>userId</code> is located.
</para>
<para>
    In this way, all the comets in the cloud know where a particular <code>userId</code> resides.
    Further associations of the same <code>userId</code> (with different sessions) on the same <code>Seti</code>
    do not broadcast any presence message, because other <code>Setis</code> already know that that
    particular <code>userId</code> resides in that <code>Seti</code>.
    The same <code>userId</code> can be associated in different comets (for example, the desktop
    computer logs in – and therefore is associated – in <code>comet1</code>, while the mobile device
    is associated in <code>comet2</code>).
</para>
<para>
    Similarly, you can disassociate a <code>userId</code> at any time by calling
    <code>Seti.disassociate(userId, session)</code>.
    If the user disconnects or "disappears" (for example, it crashed or its network dropped), the server removes or expires its
    session and <code>Seti</code> automatically
    disassociates the <code>userId</code>.
    When the last disassociation of a particular <code>userId</code> occurs on a <code>Seti</code>
    instance, <code>Seti</code> broadcasts a presence message on the cloud (on channel <code>/seti/all</code>)
    that tells all the other comets that <code>userId</code> is no longer present on that
    <code>Seti</code> (although the same <code>userId</code> might still be associated in other <code>Setis</code>).
</para>
</section>
<section xml:id="java_oort_seti_listeners">
<info>
<title>
    Listening for Presence Messages
</title>
</info>
<para>
    Applications can register presence listeners that are notified when a presence message arrives at a <code>Seti</code> instance:
</para>
<informalexample>
<programlisting language="java"><![CDATA[
Seti seti = ...;
seti.addPresenceListener(new Seti.PresenceListener()
{
    public void presenceAdded(Event event)
    {
        System.out.printf("User ID %s is now present in comet %s%n", event.getUserId(), event.getURL());
    }

    public void presenceRemoved(Event event)
    {
        System.out.printf("User ID %s is now absent in comet %s%n", event.getUserId(), event.getURL());
    }
});
]]></programlisting>
</informalexample>
<para>
    The URL <code>event.getURL()</code> returns is the URL of an Oort comet; you can use it to
    retrieve the <code>OortComet</code> instance connected to that comet, for example to publish messages
    (or to subscribe to additional channels):
</para>
<informalexample>
<programlisting language="java"><![CDATA[
final Seti seti = ...;
seti.addPresenceListener(new Seti.PresenceListener()
{
    public void presenceAdded(Event event)
    {
        Oort oort = seti.getOort();
        String oortURL = event.getURL();
        OortComet oortComet = oort.getComet(oortURL);

        Map<String, Object> data = new HashMap<String, Object>
        data.put("action", "sync_request");
        data.put("userId", event.getUserId());

        oortComet.getChannel("/service/sync").publish(data);
    }

    public void presenceRemoved(Event event)
    {
    }
});
]]></programlisting>
</informalexample>
</section>
<section>
<info>
    <title>Sending Messages</title>
</info>
<para>
    After users have been associated,
    <code>Seti.sendMessage(String userId, String channel, Object data)</code> can send messages to a
    particular user in the cloud.
</para>
<informalexample>
<programlisting language="java"><![CDATA[
@Service("seti_forwarder");
public class SetiForwarder
{
    @Inject
    private Seti seti;

    @Listener("/service/forward")
    public void forward(ServerSession session, ServerMessage message)
    {
        Map<String,Object> data = message.getDataAsMap();
        String targetUserId = (String)data.get("targetUserId");
        seti.sendMessage(targetUserId, message.getChannel(), data);
    }
}
]]></programlisting>
</informalexample>
<para>
    In the example below, <code>clientA</code> wants to send a message to <code>clientC</code>
    but not to <code>clientB</code>.
    Therefore <code>clientA</code> sends a message to the server it is connected to using a
    service channel so that the message is not broadcast (see <xref linkend="javascript_subscribe" />),
    and then a specialized service (see <xref linkend="java_server_services" />) routes
    the message to the appropriate user using <code>Seti</code> (see code snippet above).
    The <code>Seti</code> on <code>cometA</code> knows that the target user is on <code>cometC</code>
    (thanks to the association) and forwards the message to <code>cometC</code>, which in turn
    delivers the message to <code>clientC</code>.
</para>

<mediaobject>
    <alt>Seti Chat</alt>
    <imageobject>
        <imagedata align="center" fileref="seti_chat.png"  format="PNG" width="3in"/>
    </imageobject>
</mediaobject>
</section>
</section>
</section>
